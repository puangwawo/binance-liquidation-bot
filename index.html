<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Signals — XRP / DOGE / PEPE</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <meta name="description" content="Simple spot/futures-friendly signals for XRP, DOGE, and PEPE using Binance + CoinGecko + basic TA (RSI, MA) with Telegram alerts." />
  <style>
    :root { color-scheme: dark light; }
    .badge { @apply text-xs px-2 py-0.5 rounded-full font-semibold; }
    .chip { @apply text-[11px] px-2 py-1 rounded-full border; }
    .card { @apply rounded-2xl shadow-lg p-5 bg-white/70 dark:bg-slate-900/70 backdrop-blur border border-slate-200/40 dark:border-slate-800; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-100 to-slate-200 dark:from-slate-950 dark:to-slate-900 text-slate-900 dark:text-slate-100">
  <div class="max-w-7xl mx-auto px-4 py-6">
    <header class="flex items-center justify-between gap-3 mb-6">
      <div>
        <h1 class="text-2xl md:text-3xl font-bold tracking-tight">Crypto Signals — <span class="text-indigo-500">XRP</span> / <span class="text-teal-500">DOGE</span> / <span class="text-lime-500">PEPE</span></h1>
        <p class="text-sm text-slate-500 dark:text-slate-400">Live prices from Binance + market caps from CoinGecko. TA: RSI (14), MA20/MA50 on 1H. Auto-refresh ~20s.</p>
      </div>
      <div class="flex items-center gap-2">
        <button id="refreshBtn" class="chip">Refresh</button>
        <span id="lastUpdated" class="chip">—</span>
        <label class="inline-flex items-center gap-2 text-xs cursor-pointer select-none">
          <input id="autoRefresh" type="checkbox" class="accent-indigo-500" checked>
          Auto
        </label>
      </div>
    </header>

    <!-- Settings -->
    <section class="card mb-6">
      <div class="flex flex-wrap items-center gap-2">
        <span class="chip">Risk per trade ≤ 2%</span>
        <span class="chip">Timeframes: 15m + 1h</span>
        <span class="chip">Signals: bounce / breakdown / breakout</span>
        <button id="exportJson" class="chip">Export JSON</button>
        <span class="mx-2"></span>
        <label class="inline-flex items-center gap-2 text-xs cursor-pointer select-none ml-auto">
          <input id="tgToggle" type="checkbox" class="accent-indigo-500" checked>
          Telegram Alerts
        </label>
        <button id="tgTest" class="chip">Test Telegram</button>
        <input id="tgToken" class="chip w-56" placeholder="Bot Token" value="7929662766:AAEnL_VsaMi_iBCqRd4CZGnFBe3HST-J1jI"/>
        <input id="tgChats" class="chip w-48" placeholder="Chat IDs (comma)" value="1392975690"/>
      </div>
      <div class="mt-2 text-[11px] text-amber-600 dark:text-amber-400">⚠️ Token di-embed di client artinya publik bisa melihatnya (view-source). Untuk produksi, pakai serverless proxy (Cloudflare Workers/Netlify) agar token tersembunyi.</div>
    </section>

    <main id="grid" class="grid gap-4 md:grid-cols-2 lg:grid-cols-3"></main>

    <footer class="mt-10 text-center text-xs text-slate-500 dark:text-slate-400">
      <p>Data: Binance & CoinGecko • Built for copy-paste hosting (GitHub Pages / simple static host)</p>
    </footer>
  </div>

<script>
// ====== CONFIG ======
const SYMBOLS = [
  { symbol: 'XRPUSDT', display: 'XRP', coingeckoId: 'ripple', color: 'indigo' },
  { symbol: 'DOGEUSDT', display: 'DOGE', coingeckoId: 'dogecoin', color: 'teal' },
  { symbol: 'PEPEUSDT', display: 'PEPE', coingeckoId: 'pepe', color: 'lime' },
];
const POLL_MS = 20000; // 20s

// Telegram (client-side) — WARNING: Token visible publicly.
let TELEGRAM = {
  enabled: true,
  token: '7929662766:AAEnL_VsaMi_iBCqRd4CZGnFBe3HST-J1jI',
  chatIds: ['1392975690'],
  cooldownSec: 600 // 10 minutes per symbol
};

// ====== HELPERS ======
const fmt = (n, d=4) => {
  if (n === null || n === undefined || isNaN(n)) return '—';
  return Number(n).toLocaleString(undefined, { maximumFractionDigits: d });
};
const now = () => new Date().toLocaleString();
function percent(from, to){ if (!from || !to) return 0; return ((to - from) / from) * 100; }

// Simple RSI(14)
function rsi(values, period = 14){
  if (!values || values.length < period + 1) return null;
  let gains = 0, losses = 0;
  for (let i = 1; i <= period; i++){
    const diff = values[i] - values[i-1];
    if (diff >= 0) gains += diff; else losses -= diff;
  }
  let avgGain = gains / period;
  let avgLoss = losses / period;
  for (let i = period + 1; i < values.length; i++){
    const diff = values[i] - values[i-1];
    avgGain = (avgGain * (period - 1) + Math.max(diff, 0)) / period;
    avgLoss = (avgLoss * (period - 1) + Math.max(-diff, 0)) / period;
  }
  if (avgLoss === 0) return 100;
  const rs = avgGain / avgLoss;
  return 100 - (100 / (1 + rs));
}

function sma(values, period){
  if (!values || values.length < period) return null;
  const slice = values.slice(-period);
  const sum = slice.reduce((a,b)=>a + b, 0);
  return sum / period;
}

// ====== API ======
const BINANCE = 'https://api.binance.com';
async function fetch24h(symbol){
  const url = `${BINANCE}/api/v3/ticker/24hr?symbol=${symbol}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('24hr fetch failed');
  return res.json();
}
async function fetchPrice(symbol){
  const url = `${BINANCE}/api/v3/ticker/price?symbol=${symbol}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('price fetch failed');
  return res.json();
}
async function fetchKlines(symbol, interval='15m', limit=120){
  const url = `${BINANCE}/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('klines fetch failed');
  return res.json();
}
async function fetchCG(ids){
  const url = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${ids.join(',')}&order=market_cap_desc&per_page=3&page=1&sparkline=false&price_change_percentage=24h`;
  const res = await fetch(url, { headers: { 'accept': 'application/json' } });
  if (!res.ok) throw new Error('coingecko fetch failed');
  return res.json();
}

// ====== SIGNAL LOGIC ======
function buildSignals({ price, low, high, rsi15, rsi1h, ma20, ma50 }){
  const sigs = [];
  const nearLow = price <= low * 1.005; // within 0.5% of 24h low
  const nearHigh = price >= high * 0.995; // within 0.5% of 24h high
  const trendUp = ma20 && ma50 ? ma20 > ma50 : false;
  const trendDown = ma20 && ma50 ? ma20 < ma50 : false;

  // Bounce Buy
  if (nearLow && rsi15 !== null && rsi15 < 35){
    sigs.push({
      type: 'BUY', name: 'Bounce @ 24h Low',
      strength: (30 - rsi15) > 0 ? 'Strong' : 'Moderate',
      entry: price,
      sl: Number((low * 0.985).toFixed(12)),
      tp1: Number((low + (high-low)*0.5).toFixed(12)),
      tp2: Number((high).toFixed(12)),
      reason: `Price near 24h low & RSI15 ${rsi15.toFixed(1)} (<35)${trendUp ? ', 1H MA20>MA50' : ''}`
    });
  }
  // Breakout Buy
  if (price > high && rsi15 !== null && rsi15 > 55){
    sigs.push({
      type: 'BUY', name: 'Breakout > 24h High',
      strength: trendUp ? 'Strong' : 'Moderate',
      entry: price,
      sl: Number((high * 0.99).toFixed(12)),
      tp1: Number((high * 1.015).toFixed(12)),
      tp2: Number((high * 1.03).toFixed(12)),
      reason: `Breakout above 24h high & RSI15 ${rsi15.toFixed(1)} (>55)`
    });
  }
  // Breakdown Sell
  if (price < low && rsi15 !== null && rsi15 < 45){
    sigs.push({
      type: 'SELL', name: 'Breakdown < 24h Low',
      strength: trendDown ? 'Strong' : 'Moderate',
      entry: price,
      sl: Number((low * 1.01).toFixed(12)),
      tp1: Number((low * 0.985).toFixed(12)),
      tp2: Number((low * 0.97).toFixed(12)),
      reason: `Lost 24h low & RSI15 ${rsi15.toFixed(1)} (<45)`
    });
  }
  // Take-Profit zone hint
  if (nearHigh && rsi15 !== null && rsi15 > 65){
    sigs.push({
      type: 'INFO', name: 'Near 24h High', strength: 'TP Area',
      entry: price, sl: null,
      tp1: Number((high).toFixed(12)),
      tp2: Number((high * 1.01).toFixed(12)),
      reason: `Price near 24h high & RSI15 ${rsi15.toFixed(1)} (>65)`
    });
  }
  return sigs;
}

// --- Telegram helpers ---
function tgEndpoint(){ return `https://api.telegram.org/bot${TELEGRAM.token}/sendMessage`; }
async function sendTelegramMessage(text){
  if (!TELEGRAM.enabled || !TELEGRAM.token || !TELEGRAM.chatIds?.length) return;
  const bodyBase = `parse_mode=HTML&disable_web_page_preview=true&text=${encodeURIComponent(text)}`;
  const tasks = TELEGRAM.chatIds.map(cid => fetch(tgEndpoint(), {
    method: 'POST', mode: 'no-cors', headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: `chat_id=${encodeURIComponent(cid)}&${bodyBase}`
  }).catch(()=>{}));
  await Promise.all(tasks);
}
function formatSigText(sym, s){
  return [
    `<b>${sym.display}</b> — <b>${s.type}</b> · ${s.name}`,
    `Entry: <code>${s.entry}</code> | SL: <code>${s.sl ?? '—'}</code> | TP1: <code>${s.tp1}</code> | TP2: <code>${s.tp2}</code>`,
    `${s.reason}`,
    `#${sym.display} #signal`
  ].join('\n');
}
function pickPrimarySignal(sigs){
  if (!sigs || sigs.length === 0) return null;
  const priority = { SELL: 2, BUY: 1, INFO: 0 };
  return [...sigs].sort((a,b)=>priority[b.type]-priority[a.type])[0];
}

// ====== UI RENDER ======
function cardTemplate(key, display, color){
  return `
  <section id="card-${key}" class="card">
    <div class="flex items-center justify-between mb-3">
      <div class="flex items-center gap-2">
        <div class="badge bg-${color}-500/15 text-${color}-600 dark:text-${color}-400 border border-${color}-500/20">${display}</div>
        <span id="price-${key}" class="text-lg font-semibold">—</span>
      </div>
      <div class="text-xs text-slate-500" id="pct-${key}">—</div>
    </div>
    <div class="grid grid-cols-2 gap-3 text-sm">
      <div>
        <div class="text-slate-500">24h Low</div>
        <div id="low-${key}" class="font-medium">—</div>
      </div>
      <div>
        <div class="text-slate-500">24h High</div>
        <div id="high-${key}" class="font-medium">—</div>
      </div>
      <div>
        <div class="text-slate-500">RSI 15m</div>
        <div id="rsi15-${key}" class="font-medium">—</div>
      </div>
      <div>
        <div class="text-slate-500">RSI 1h</div>
        <div id="rsi1h-${key}" class="font-medium">—</div>
      </div>
      <div>
        <div class="text-slate-500">1H MA20</div>
        <div id="ma20-${key}" class="font-medium">—</div>
      </div>
      <div>
        <div class="text-slate-500">1H MA50</div>
        <div id="ma50-${key}" class="font-medium">—</div>
      </div>
      <div class="col-span-2">
        <div class="text-slate-500">Market Cap (CG)</div>
        <div id="mcap-${key}" class="font-medium">—</div>
      </div>
    </div>
    <div id="signals-${key}" class="mt-4 space-y-3"></div>
  </section>`
}

function renderSignals(el, sigs){
  if (!sigs || sigs.length === 0){
    el.innerHTML = `<div class="text-xs text-slate-500">No immediate setups. Wait for levels.</div>`;
    return;
  }
  el.innerHTML = sigs.map(s => `
    <div class="border rounded-xl p-3 ${s.type==='BUY' ? 'border-emerald-500/40 bg-emerald-500/5' : s.type==='SELL' ? 'border-rose-500/40 bg-rose-500/5' : 'border-amber-500/40 bg-amber-500/5'}">
      <div class="flex items-center justify-between">
        <div class="text-sm font-semibold">${s.type} · ${s.name}</div>
        <div class="badge ${s.type==='BUY' ? 'bg-emerald-500/20 text-emerald-600 dark:text-emerald-400' : s.type==='SELL' ? 'bg-rose-500/20 text-rose-600 dark:text-rose-400' : 'bg-amber-500/20 text-amber-600 dark:text-amber-400'}">${s.strength}</div>
      </div>
      <div class="mt-2 grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
        <div><span class="text-slate-500">Entry</span><div class="font-mono">${fmt(s.entry, 12)}</div></div>
        <div><span class="text-slate-500">SL</span><div class="font-mono">${s.sl ? fmt(s.sl, 12) : '—'}</div></div>
        <div><span class="text-slate-500">TP1</span><div class="font-mono">${fmt(s.tp1, 12)}</div></div>
        <div><span class="text-slate-500">TP2</span><div class="font-mono">${fmt(s.tp2, 12)}</div></div>
      </div>
      <div class="mt-2 text-[11px] text-slate-500">${s.reason}</div>
    </div>
  `).join('');
}

// ====== STATE ======
const state = {};

async function loadCoinGecko(){
  const ids = SYMBOLS.map(s => s.coingeckoId);
  const data = await fetchCG(ids);
  data.forEach(coin => { state[`cg-${coin.id}`] = coin; });
}

async function loadSymbol(symObj){
  const key = symObj.symbol;
  const [t24, priceObj, k15, k1h] = await Promise.all([
    fetch24h(key),
    fetchPrice(key),
    fetchKlines(key, '15m', 200),
    fetchKlines(key, '1h', 200)
  ]);

  const price = Number(priceObj.price);
  const low = Number(t24.lowPrice);
  const high = Number(t24.highPrice);
  const closes15 = k15.map(k=>Number(k[4]));
  const closes1h = k1h.map(k=>Number(k[4]));
  const rsi15 = rsi(closes15, 14);
  const rsi1h = rsi(closes1h, 14);
  const ma20 = sma(closes1h, 20);
  const ma50 = sma(closes1h, 50);

  const sigs = buildSignals({ price, low, high, rsi15, rsi1h, ma20, ma50 });
  state[key] = { t24, price, low, high, rsi15, rsi1h, ma20, ma50, sigs, lastAlertSig: state[key]?.lastAlertSig, lastAlertAt: state[key]?.lastAlertAt };
}

function paint(symObj){
  const key = symObj.symbol;
  const id = symObj.coingeckoId;
  const s = state[key];
  const cg = state[`cg-${id}`];
  if (!s) return;

  document.getElementById(`price-${key}`).textContent = `$${fmt(s.price, 12)}`;
  document.getElementById(`low-${key}`).textContent = `$${fmt(s.low, 12)}`;
  document.getElementById(`high-${key}`).textContent = `$${fmt(s.high, 12)}`;
  document.getElementById(`rsi15-${key}`).textContent = s.rsi15 ? s.rsi15.toFixed(1) : '—';
  document.getElementById(`rsi1h-${key}`).textContent = s.rsi1h ? s.rsi1h.toFixed(1) : '—';
  document.getElementById(`ma20-${key}`).textContent = s.ma20 ? `$${fmt(s.ma20, 12)}` : '—';
  document.getElementById(`ma50-${key}`).textContent = s.ma50 ? `$${fmt(s.ma50, 12)}` : '—';
  const pct = percent(s.low, s.price);
  document.getElementById(`pct-${key}`).textContent = `from 24h Low: ${pct.toFixed(2)}%`;
  if (cg){
    const mcap = cg.market_cap ? `$${cg.market_cap.toLocaleString()}` : '—';
    document.getElementById(`mcap-${key}`).textContent = `${mcap} • 24h Vol: $${(cg.total_volume||0).toLocaleString()}`;
  }

  renderSignals(document.getElementById(`signals-${key}`), s.sigs);

  // Telegram alert (edge + cooldown)
  const primary = pickPrimarySignal(s.sigs);
  if (primary){
    const sigKey = `${primary.type}|${primary.name}|${primary.sl}|${primary.tp1}|${primary.tp2}`;
    const nowSec = Math.floor(Date.now()/1000);
    const lastKey = s.lastAlertSig;
    const lastAt = s.lastAlertAt || 0;
    const cooled = (nowSec - lastAt) >= (TELEGRAM.cooldownSec || 0);
    if (sigKey !== lastKey && cooled){
      sendTelegramMessage(formatSigText(symObj, primary));
      s.lastAlertSig = sigKey;
      s.lastAlertAt = nowSec;
    }
  }
}

async function refreshAll(){
  try{ await loadCoinGecko(); }catch(e){ console.warn('CG error', e); }
  await Promise.all(SYMBOLS.map(loadSymbol));
  SYMBOLS.forEach(paint);
  document.getElementById('lastUpdated').textContent = now();
}

// ====== INIT ======
const grid = document.getElementById('grid');
SYMBOLS.forEach(s => grid.insertAdjacentHTML('beforeend', cardTemplate(s.symbol, s.display, s.color)));

let timer = null;
function startAuto(){ if (timer) clearInterval(timer); timer = setInterval(refreshAll, POLL_MS); }
refreshAll().then(startAuto);

// Controls
const autoChk = document.getElementById('autoRefresh');
const refreshBtn = document.getElementById('refreshBtn');
refreshBtn.addEventListener('click', refreshAll);
autoChk.addEventListener('change', (e)=>{ if (e.target.checked) startAuto(); else { if (timer) clearInterval(timer); } });

// Telegram controls
const tgToggle = document.getElementById('tgToggle');
const tgToken = document.getElementById('tgToken');
const tgChats = document.getElementById('tgChats');
const tgTest = document.getElementById('tgTest');

tgToggle.checked = TELEGRAM.enabled;
tgToken.value = TELEGRAM.token || '';
tgChats.value = (TELEGRAM.chatIds||[]).join(',');

tgToggle.addEventListener('change', e => { TELEGRAM.enabled = !!e.target.checked; });
tgToken.addEventListener('input', e => { TELEGRAM.token = e.target.value.trim(); });
tgChats.addEventListener('input', e => { TELEGRAM.chatIds = e.target.value.split(',').map(s=>s.trim()).filter(Boolean); });

tgTest.addEventListener('click', ()=>{ sendTelegramMessage('<b>Test</b> — Alerts aktif ✅'); });

// Export JSON
const exportBtn = document.getElementById('exportJson');
exportBtn.addEventListener('click', ()=>{
  const out = SYMBOLS.map(s => ({ symbol: s.symbol, ...(state[s.symbol]||{}) }));
  const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `signals-${Date.now()}.json`; a.click();
  URL.revokeObjectURL(url);
});
</script>
</body>
</html>
